{"version":3,"file":"entrypoint-Oq5q_Wuc.js","sources":["../../../Client/src/api/core/bodySerializer.gen.ts","../../../Client/src/api/core/serverSentEvents.gen.ts","../../../Client/src/api/core/pathSerializer.gen.ts","../../../Client/src/api/core/utils.gen.ts","../../../Client/src/api/core/auth.gen.ts","../../../Client/src/api/client/utils.gen.ts","../../../Client/src/api/client/client.gen.ts","../../../Client/src/api/client.gen.ts","../../../Client/src/entrypoints/entrypoint.ts"],"sourcesContent":["// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport type {\r\n  ArrayStyle,\r\n  ObjectStyle,\r\n  SerializerOptions,\r\n} from './pathSerializer.gen';\r\n\r\nexport type QuerySerializer = (query: Record<string, unknown>) => string;\r\n\r\nexport type BodySerializer = (body: any) => any;\r\n\r\nexport interface QuerySerializerOptions {\r\n  allowReserved?: boolean;\r\n  array?: SerializerOptions<ArrayStyle>;\r\n  object?: SerializerOptions<ObjectStyle>;\r\n}\r\n\r\nconst serializeFormDataPair = (\r\n  data: FormData,\r\n  key: string,\r\n  value: unknown,\r\n): void => {\r\n  if (typeof value === 'string' || value instanceof Blob) {\r\n    data.append(key, value);\r\n  } else if (value instanceof Date) {\r\n    data.append(key, value.toISOString());\r\n  } else {\r\n    data.append(key, JSON.stringify(value));\r\n  }\r\n};\r\n\r\nconst serializeUrlSearchParamsPair = (\r\n  data: URLSearchParams,\r\n  key: string,\r\n  value: unknown,\r\n): void => {\r\n  if (typeof value === 'string') {\r\n    data.append(key, value);\r\n  } else {\r\n    data.append(key, JSON.stringify(value));\r\n  }\r\n};\r\n\r\nexport const formDataBodySerializer = {\r\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\r\n    body: T,\r\n  ): FormData => {\r\n    const data = new FormData();\r\n\r\n    Object.entries(body).forEach(([key, value]) => {\r\n      if (value === undefined || value === null) {\r\n        return;\r\n      }\r\n      if (Array.isArray(value)) {\r\n        value.forEach((v) => serializeFormDataPair(data, key, v));\r\n      } else {\r\n        serializeFormDataPair(data, key, value);\r\n      }\r\n    });\r\n\r\n    return data;\r\n  },\r\n};\r\n\r\nexport const jsonBodySerializer = {\r\n  bodySerializer: <T>(body: T): string =>\r\n    JSON.stringify(body, (_key, value) =>\r\n      typeof value === 'bigint' ? value.toString() : value,\r\n    ),\r\n};\r\n\r\nexport const urlSearchParamsBodySerializer = {\r\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\r\n    body: T,\r\n  ): string => {\r\n    const data = new URLSearchParams();\r\n\r\n    Object.entries(body).forEach(([key, value]) => {\r\n      if (value === undefined || value === null) {\r\n        return;\r\n      }\r\n      if (Array.isArray(value)) {\r\n        value.forEach((v) => serializeUrlSearchParamsPair(data, key, v));\r\n      } else {\r\n        serializeUrlSearchParamsPair(data, key, value);\r\n      }\r\n    });\r\n\r\n    return data.toString();\r\n  },\r\n};\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport type { Config } from './types.gen';\r\n\r\nexport type ServerSentEventsOptions<TData = unknown> = Omit<\r\n  RequestInit,\r\n  'method'\r\n> &\r\n  Pick<Config, 'method' | 'responseTransformer' | 'responseValidator'> & {\r\n    /**\r\n     * Fetch API implementation. You can use this option to provide a custom\r\n     * fetch instance.\r\n     *\r\n     * @default globalThis.fetch\r\n     */\r\n    fetch?: typeof fetch;\r\n    /**\r\n     * Implementing clients can call request interceptors inside this hook.\r\n     */\r\n    onRequest?: (url: string, init: RequestInit) => Promise<Request>;\r\n    /**\r\n     * Callback invoked when a network or parsing error occurs during streaming.\r\n     *\r\n     * This option applies only if the endpoint returns a stream of events.\r\n     *\r\n     * @param error The error that occurred.\r\n     */\r\n    onSseError?: (error: unknown) => void;\r\n    /**\r\n     * Callback invoked when an event is streamed from the server.\r\n     *\r\n     * This option applies only if the endpoint returns a stream of events.\r\n     *\r\n     * @param event Event streamed from the server.\r\n     * @returns Nothing (void).\r\n     */\r\n    onSseEvent?: (event: StreamEvent<TData>) => void;\r\n    serializedBody?: RequestInit['body'];\r\n    /**\r\n     * Default retry delay in milliseconds.\r\n     *\r\n     * This option applies only if the endpoint returns a stream of events.\r\n     *\r\n     * @default 3000\r\n     */\r\n    sseDefaultRetryDelay?: number;\r\n    /**\r\n     * Maximum number of retry attempts before giving up.\r\n     */\r\n    sseMaxRetryAttempts?: number;\r\n    /**\r\n     * Maximum retry delay in milliseconds.\r\n     *\r\n     * Applies only when exponential backoff is used.\r\n     *\r\n     * This option applies only if the endpoint returns a stream of events.\r\n     *\r\n     * @default 30000\r\n     */\r\n    sseMaxRetryDelay?: number;\r\n    /**\r\n     * Optional sleep function for retry backoff.\r\n     *\r\n     * Defaults to using `setTimeout`.\r\n     */\r\n    sseSleepFn?: (ms: number) => Promise<void>;\r\n    url: string;\r\n  };\r\n\r\nexport interface StreamEvent<TData = unknown> {\r\n  data: TData;\r\n  event?: string;\r\n  id?: string;\r\n  retry?: number;\r\n}\r\n\r\nexport type ServerSentEventsResult<\r\n  TData = unknown,\r\n  TReturn = void,\r\n  TNext = unknown,\r\n> = {\r\n  stream: AsyncGenerator<\r\n    TData extends Record<string, unknown> ? TData[keyof TData] : TData,\r\n    TReturn,\r\n    TNext\r\n  >;\r\n};\r\n\r\nexport const createSseClient = <TData = unknown>({\r\n  onRequest,\r\n  onSseError,\r\n  onSseEvent,\r\n  responseTransformer,\r\n  responseValidator,\r\n  sseDefaultRetryDelay,\r\n  sseMaxRetryAttempts,\r\n  sseMaxRetryDelay,\r\n  sseSleepFn,\r\n  url,\r\n  ...options\r\n}: ServerSentEventsOptions): ServerSentEventsResult<TData> => {\r\n  let lastEventId: string | undefined;\r\n\r\n  const sleep =\r\n    sseSleepFn ??\r\n    ((ms: number) => new Promise((resolve) => setTimeout(resolve, ms)));\r\n\r\n  const createStream = async function* () {\r\n    let retryDelay: number = sseDefaultRetryDelay ?? 3000;\r\n    let attempt = 0;\r\n    const signal = options.signal ?? new AbortController().signal;\r\n\r\n    while (true) {\r\n      if (signal.aborted) break;\r\n\r\n      attempt++;\r\n\r\n      const headers =\r\n        options.headers instanceof Headers\r\n          ? options.headers\r\n          : new Headers(options.headers as Record<string, string> | undefined);\r\n\r\n      if (lastEventId !== undefined) {\r\n        headers.set('Last-Event-ID', lastEventId);\r\n      }\r\n\r\n      try {\r\n        const requestInit: RequestInit = {\r\n          redirect: 'follow',\r\n          ...options,\r\n          body: options.serializedBody,\r\n          headers,\r\n          signal,\r\n        };\r\n        let request = new Request(url, requestInit);\r\n        if (onRequest) {\r\n          request = await onRequest(url, requestInit);\r\n        }\r\n        // fetch must be assigned here, otherwise it would throw the error:\r\n        // TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation\r\n        const _fetch = options.fetch ?? globalThis.fetch;\r\n        const response = await _fetch(request);\r\n\r\n        if (!response.ok)\r\n          throw new Error(\r\n            `SSE failed: ${response.status} ${response.statusText}`,\r\n          );\r\n\r\n        if (!response.body) throw new Error('No body in SSE response');\r\n\r\n        const reader = response.body\r\n          .pipeThrough(new TextDecoderStream())\r\n          .getReader();\r\n\r\n        let buffer = '';\r\n\r\n        const abortHandler = () => {\r\n          try {\r\n            reader.cancel();\r\n          } catch {\r\n            // noop\r\n          }\r\n        };\r\n\r\n        signal.addEventListener('abort', abortHandler);\r\n\r\n        try {\r\n          while (true) {\r\n            const { done, value } = await reader.read();\r\n            if (done) break;\r\n            buffer += value;\r\n\r\n            const chunks = buffer.split('\\n\\n');\r\n            buffer = chunks.pop() ?? '';\r\n\r\n            for (const chunk of chunks) {\r\n              const lines = chunk.split('\\n');\r\n              const dataLines: Array<string> = [];\r\n              let eventName: string | undefined;\r\n\r\n              for (const line of lines) {\r\n                if (line.startsWith('data:')) {\r\n                  dataLines.push(line.replace(/^data:\\s*/, ''));\r\n                } else if (line.startsWith('event:')) {\r\n                  eventName = line.replace(/^event:\\s*/, '');\r\n                } else if (line.startsWith('id:')) {\r\n                  lastEventId = line.replace(/^id:\\s*/, '');\r\n                } else if (line.startsWith('retry:')) {\r\n                  const parsed = Number.parseInt(\r\n                    line.replace(/^retry:\\s*/, ''),\r\n                    10,\r\n                  );\r\n                  if (!Number.isNaN(parsed)) {\r\n                    retryDelay = parsed;\r\n                  }\r\n                }\r\n              }\r\n\r\n              let data: unknown;\r\n              let parsedJson = false;\r\n\r\n              if (dataLines.length) {\r\n                const rawData = dataLines.join('\\n');\r\n                try {\r\n                  data = JSON.parse(rawData);\r\n                  parsedJson = true;\r\n                } catch {\r\n                  data = rawData;\r\n                }\r\n              }\r\n\r\n              if (parsedJson) {\r\n                if (responseValidator) {\r\n                  await responseValidator(data);\r\n                }\r\n\r\n                if (responseTransformer) {\r\n                  data = await responseTransformer(data);\r\n                }\r\n              }\r\n\r\n              onSseEvent?.({\r\n                data,\r\n                event: eventName,\r\n                id: lastEventId,\r\n                retry: retryDelay,\r\n              });\r\n\r\n              if (dataLines.length) {\r\n                yield data as any;\r\n              }\r\n            }\r\n          }\r\n        } finally {\r\n          signal.removeEventListener('abort', abortHandler);\r\n          reader.releaseLock();\r\n        }\r\n\r\n        break; // exit loop on normal completion\r\n      } catch (error) {\r\n        // connection failed or aborted; retry after delay\r\n        onSseError?.(error);\r\n\r\n        if (\r\n          sseMaxRetryAttempts !== undefined &&\r\n          attempt >= sseMaxRetryAttempts\r\n        ) {\r\n          break; // stop after firing error\r\n        }\r\n\r\n        // exponential backoff: double retry each attempt, cap at 30s\r\n        const backoff = Math.min(\r\n          retryDelay * 2 ** (attempt - 1),\r\n          sseMaxRetryDelay ?? 30000,\r\n        );\r\n        await sleep(backoff);\r\n      }\r\n    }\r\n  };\r\n\r\n  const stream = createStream();\r\n\r\n  return { stream };\r\n};\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\ninterface SerializeOptions<T>\r\n  extends SerializePrimitiveOptions,\r\n    SerializerOptions<T> {}\r\n\r\ninterface SerializePrimitiveOptions {\r\n  allowReserved?: boolean;\r\n  name: string;\r\n}\r\n\r\nexport interface SerializerOptions<T> {\r\n  /**\r\n   * @default true\r\n   */\r\n  explode: boolean;\r\n  style: T;\r\n}\r\n\r\nexport type ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';\r\nexport type ArraySeparatorStyle = ArrayStyle | MatrixStyle;\r\ntype MatrixStyle = 'label' | 'matrix' | 'simple';\r\nexport type ObjectStyle = 'form' | 'deepObject';\r\ntype ObjectSeparatorStyle = ObjectStyle | MatrixStyle;\r\n\r\ninterface SerializePrimitiveParam extends SerializePrimitiveOptions {\r\n  value: string;\r\n}\r\n\r\nexport const separatorArrayExplode = (style: ArraySeparatorStyle) => {\r\n  switch (style) {\r\n    case 'label':\r\n      return '.';\r\n    case 'matrix':\r\n      return ';';\r\n    case 'simple':\r\n      return ',';\r\n    default:\r\n      return '&';\r\n  }\r\n};\r\n\r\nexport const separatorArrayNoExplode = (style: ArraySeparatorStyle) => {\r\n  switch (style) {\r\n    case 'form':\r\n      return ',';\r\n    case 'pipeDelimited':\r\n      return '|';\r\n    case 'spaceDelimited':\r\n      return '%20';\r\n    default:\r\n      return ',';\r\n  }\r\n};\r\n\r\nexport const separatorObjectExplode = (style: ObjectSeparatorStyle) => {\r\n  switch (style) {\r\n    case 'label':\r\n      return '.';\r\n    case 'matrix':\r\n      return ';';\r\n    case 'simple':\r\n      return ',';\r\n    default:\r\n      return '&';\r\n  }\r\n};\r\n\r\nexport const serializeArrayParam = ({\r\n  allowReserved,\r\n  explode,\r\n  name,\r\n  style,\r\n  value,\r\n}: SerializeOptions<ArraySeparatorStyle> & {\r\n  value: unknown[];\r\n}) => {\r\n  if (!explode) {\r\n    const joinedValues = (\r\n      allowReserved ? value : value.map((v) => encodeURIComponent(v as string))\r\n    ).join(separatorArrayNoExplode(style));\r\n    switch (style) {\r\n      case 'label':\r\n        return `.${joinedValues}`;\r\n      case 'matrix':\r\n        return `;${name}=${joinedValues}`;\r\n      case 'simple':\r\n        return joinedValues;\r\n      default:\r\n        return `${name}=${joinedValues}`;\r\n    }\r\n  }\r\n\r\n  const separator = separatorArrayExplode(style);\r\n  const joinedValues = value\r\n    .map((v) => {\r\n      if (style === 'label' || style === 'simple') {\r\n        return allowReserved ? v : encodeURIComponent(v as string);\r\n      }\r\n\r\n      return serializePrimitiveParam({\r\n        allowReserved,\r\n        name,\r\n        value: v as string,\r\n      });\r\n    })\r\n    .join(separator);\r\n  return style === 'label' || style === 'matrix'\r\n    ? separator + joinedValues\r\n    : joinedValues;\r\n};\r\n\r\nexport const serializePrimitiveParam = ({\r\n  allowReserved,\r\n  name,\r\n  value,\r\n}: SerializePrimitiveParam) => {\r\n  if (value === undefined || value === null) {\r\n    return '';\r\n  }\r\n\r\n  if (typeof value === 'object') {\r\n    throw new Error(\r\n      'Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.',\r\n    );\r\n  }\r\n\r\n  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;\r\n};\r\n\r\nexport const serializeObjectParam = ({\r\n  allowReserved,\r\n  explode,\r\n  name,\r\n  style,\r\n  value,\r\n  valueOnly,\r\n}: SerializeOptions<ObjectSeparatorStyle> & {\r\n  value: Record<string, unknown> | Date;\r\n  valueOnly?: boolean;\r\n}) => {\r\n  if (value instanceof Date) {\r\n    return valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;\r\n  }\r\n\r\n  if (style !== 'deepObject' && !explode) {\r\n    let values: string[] = [];\r\n    Object.entries(value).forEach(([key, v]) => {\r\n      values = [\r\n        ...values,\r\n        key,\r\n        allowReserved ? (v as string) : encodeURIComponent(v as string),\r\n      ];\r\n    });\r\n    const joinedValues = values.join(',');\r\n    switch (style) {\r\n      case 'form':\r\n        return `${name}=${joinedValues}`;\r\n      case 'label':\r\n        return `.${joinedValues}`;\r\n      case 'matrix':\r\n        return `;${name}=${joinedValues}`;\r\n      default:\r\n        return joinedValues;\r\n    }\r\n  }\r\n\r\n  const separator = separatorObjectExplode(style);\r\n  const joinedValues = Object.entries(value)\r\n    .map(([key, v]) =>\r\n      serializePrimitiveParam({\r\n        allowReserved,\r\n        name: style === 'deepObject' ? `${name}[${key}]` : key,\r\n        value: v as string,\r\n      }),\r\n    )\r\n    .join(separator);\r\n  return style === 'label' || style === 'matrix'\r\n    ? separator + joinedValues\r\n    : joinedValues;\r\n};\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport type { BodySerializer, QuerySerializer } from './bodySerializer.gen';\r\nimport {\r\n  type ArraySeparatorStyle,\r\n  serializeArrayParam,\r\n  serializeObjectParam,\r\n  serializePrimitiveParam,\r\n} from './pathSerializer.gen';\r\n\r\nexport interface PathSerializer {\r\n  path: Record<string, unknown>;\r\n  url: string;\r\n}\r\n\r\nexport const PATH_PARAM_RE = /\\{[^{}]+\\}/g;\r\n\r\nexport const defaultPathSerializer = ({ path, url: _url }: PathSerializer) => {\r\n  let url = _url;\r\n  const matches = _url.match(PATH_PARAM_RE);\r\n  if (matches) {\r\n    for (const match of matches) {\r\n      let explode = false;\r\n      let name = match.substring(1, match.length - 1);\r\n      let style: ArraySeparatorStyle = 'simple';\r\n\r\n      if (name.endsWith('*')) {\r\n        explode = true;\r\n        name = name.substring(0, name.length - 1);\r\n      }\r\n\r\n      if (name.startsWith('.')) {\r\n        name = name.substring(1);\r\n        style = 'label';\r\n      } else if (name.startsWith(';')) {\r\n        name = name.substring(1);\r\n        style = 'matrix';\r\n      }\r\n\r\n      const value = path[name];\r\n\r\n      if (value === undefined || value === null) {\r\n        continue;\r\n      }\r\n\r\n      if (Array.isArray(value)) {\r\n        url = url.replace(\r\n          match,\r\n          serializeArrayParam({ explode, name, style, value }),\r\n        );\r\n        continue;\r\n      }\r\n\r\n      if (typeof value === 'object') {\r\n        url = url.replace(\r\n          match,\r\n          serializeObjectParam({\r\n            explode,\r\n            name,\r\n            style,\r\n            value: value as Record<string, unknown>,\r\n            valueOnly: true,\r\n          }),\r\n        );\r\n        continue;\r\n      }\r\n\r\n      if (style === 'matrix') {\r\n        url = url.replace(\r\n          match,\r\n          `;${serializePrimitiveParam({\r\n            name,\r\n            value: value as string,\r\n          })}`,\r\n        );\r\n        continue;\r\n      }\r\n\r\n      const replaceValue = encodeURIComponent(\r\n        style === 'label' ? `.${value as string}` : (value as string),\r\n      );\r\n      url = url.replace(match, replaceValue);\r\n    }\r\n  }\r\n  return url;\r\n};\r\n\r\nexport const getUrl = ({\r\n  baseUrl,\r\n  path,\r\n  query,\r\n  querySerializer,\r\n  url: _url,\r\n}: {\r\n  baseUrl?: string;\r\n  path?: Record<string, unknown>;\r\n  query?: Record<string, unknown>;\r\n  querySerializer: QuerySerializer;\r\n  url: string;\r\n}) => {\r\n  const pathUrl = _url.startsWith('/') ? _url : `/${_url}`;\r\n  let url = (baseUrl ?? '') + pathUrl;\r\n  if (path) {\r\n    url = defaultPathSerializer({ path, url });\r\n  }\r\n  let search = query ? querySerializer(query) : '';\r\n  if (search.startsWith('?')) {\r\n    search = search.substring(1);\r\n  }\r\n  if (search) {\r\n    url += `?${search}`;\r\n  }\r\n  return url;\r\n};\r\n\r\nexport function getValidRequestBody(options: {\r\n  body?: unknown;\r\n  bodySerializer?: BodySerializer | null;\r\n  serializedBody?: unknown;\r\n}) {\r\n  const hasBody = options.body !== undefined;\r\n  const isSerializedBody = hasBody && options.bodySerializer;\r\n\r\n  if (isSerializedBody) {\r\n    if ('serializedBody' in options) {\r\n      const hasSerializedBody =\r\n        options.serializedBody !== undefined && options.serializedBody !== '';\r\n\r\n      return hasSerializedBody ? options.serializedBody : null;\r\n    }\r\n\r\n    // not all clients implement a serializedBody property (i.e. client-axios)\r\n    return options.body !== '' ? options.body : null;\r\n  }\r\n\r\n  // plain/text body\r\n  if (hasBody) {\r\n    return options.body;\r\n  }\r\n\r\n  // no body was provided\r\n  return undefined;\r\n}\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nexport type AuthToken = string | undefined;\r\n\r\nexport interface Auth {\r\n  /**\r\n   * Which part of the request do we use to send the auth?\r\n   *\r\n   * @default 'header'\r\n   */\r\n  in?: 'header' | 'query' | 'cookie';\r\n  /**\r\n   * Header or query parameter name.\r\n   *\r\n   * @default 'Authorization'\r\n   */\r\n  name?: string;\r\n  scheme?: 'basic' | 'bearer';\r\n  type: 'apiKey' | 'http';\r\n}\r\n\r\nexport const getAuthToken = async (\r\n  auth: Auth,\r\n  callback: ((auth: Auth) => Promise<AuthToken> | AuthToken) | AuthToken,\r\n): Promise<string | undefined> => {\r\n  const token =\r\n    typeof callback === 'function' ? await callback(auth) : callback;\r\n\r\n  if (!token) {\r\n    return;\r\n  }\r\n\r\n  if (auth.scheme === 'bearer') {\r\n    return `Bearer ${token}`;\r\n  }\r\n\r\n  if (auth.scheme === 'basic') {\r\n    return `Basic ${btoa(token)}`;\r\n  }\r\n\r\n  return token;\r\n};\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport { getAuthToken } from '../core/auth.gen';\r\nimport type { QuerySerializerOptions } from '../core/bodySerializer.gen';\r\nimport { jsonBodySerializer } from '../core/bodySerializer.gen';\r\nimport {\r\n  serializeArrayParam,\r\n  serializeObjectParam,\r\n  serializePrimitiveParam,\r\n} from '../core/pathSerializer.gen';\r\nimport { getUrl } from '../core/utils.gen';\r\nimport type { Client, ClientOptions, Config, RequestOptions } from './types.gen';\r\n\r\nexport const createQuerySerializer = <T = unknown>({\r\n  allowReserved,\r\n  array,\r\n  object,\r\n}: QuerySerializerOptions = {}) => {\r\n  const querySerializer = (queryParams: T) => {\r\n    const search: string[] = [];\r\n    if (queryParams && typeof queryParams === 'object') {\r\n      for (const name in queryParams) {\r\n        const value = queryParams[name];\r\n\r\n        if (value === undefined || value === null) {\r\n          continue;\r\n        }\r\n\r\n        if (Array.isArray(value)) {\r\n          const serializedArray = serializeArrayParam({\r\n            allowReserved,\r\n            explode: true,\r\n            name,\r\n            style: 'form',\r\n            value,\r\n            ...array,\r\n          });\r\n          if (serializedArray) search.push(serializedArray);\r\n        } else if (typeof value === 'object') {\r\n          const serializedObject = serializeObjectParam({\r\n            allowReserved,\r\n            explode: true,\r\n            name,\r\n            style: 'deepObject',\r\n            value: value as Record<string, unknown>,\r\n            ...object,\r\n          });\r\n          if (serializedObject) search.push(serializedObject);\r\n        } else {\r\n          const serializedPrimitive = serializePrimitiveParam({\r\n            allowReserved,\r\n            name,\r\n            value: value as string,\r\n          });\r\n          if (serializedPrimitive) search.push(serializedPrimitive);\r\n        }\r\n      }\r\n    }\r\n    return search.join('&');\r\n  };\r\n  return querySerializer;\r\n};\r\n\r\n/**\r\n * Infers parseAs value from provided Content-Type header.\r\n */\r\nexport const getParseAs = (\r\n  contentType: string | null,\r\n): Exclude<Config['parseAs'], 'auto'> => {\r\n  if (!contentType) {\r\n    // If no Content-Type header is provided, the best we can do is return the raw response body,\r\n    // which is effectively the same as the 'stream' option.\r\n    return 'stream';\r\n  }\r\n\r\n  const cleanContent = contentType.split(';')[0]?.trim();\r\n\r\n  if (!cleanContent) {\r\n    return;\r\n  }\r\n\r\n  if (\r\n    cleanContent.startsWith('application/json') ||\r\n    cleanContent.endsWith('+json')\r\n  ) {\r\n    return 'json';\r\n  }\r\n\r\n  if (cleanContent === 'multipart/form-data') {\r\n    return 'formData';\r\n  }\r\n\r\n  if (\r\n    ['application/', 'audio/', 'image/', 'video/'].some((type) =>\r\n      cleanContent.startsWith(type),\r\n    )\r\n  ) {\r\n    return 'blob';\r\n  }\r\n\r\n  if (cleanContent.startsWith('text/')) {\r\n    return 'text';\r\n  }\r\n\r\n  return;\r\n};\r\n\r\nconst checkForExistence = (\r\n  options: Pick<RequestOptions, 'auth' | 'query'> & {\r\n    headers: Headers;\r\n  },\r\n  name?: string,\r\n): boolean => {\r\n  if (!name) {\r\n    return false;\r\n  }\r\n  if (\r\n    options.headers.has(name) ||\r\n    options.query?.[name] ||\r\n    options.headers.get('Cookie')?.includes(`${name}=`)\r\n  ) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\nexport const setAuthParams = async ({\r\n  security,\r\n  ...options\r\n}: Pick<Required<RequestOptions>, 'security'> &\r\n  Pick<RequestOptions, 'auth' | 'query'> & {\r\n    headers: Headers;\r\n  }) => {\r\n  for (const auth of security) {\r\n    if (checkForExistence(options, auth.name)) {\r\n      continue;\r\n    }\r\n\r\n    const token = await getAuthToken(auth, options.auth);\r\n\r\n    if (!token) {\r\n      continue;\r\n    }\r\n\r\n    const name = auth.name ?? 'Authorization';\r\n\r\n    switch (auth.in) {\r\n      case 'query':\r\n        if (!options.query) {\r\n          options.query = {};\r\n        }\r\n        options.query[name] = token;\r\n        break;\r\n      case 'cookie':\r\n        options.headers.append('Cookie', `${name}=${token}`);\r\n        break;\r\n      case 'header':\r\n      default:\r\n        options.headers.set(name, token);\r\n        break;\r\n    }\r\n  }\r\n};\r\n\r\nexport const buildUrl: Client['buildUrl'] = (options) =>\r\n  getUrl({\r\n    baseUrl: options.baseUrl as string,\r\n    path: options.path,\r\n    query: options.query,\r\n    querySerializer:\r\n      typeof options.querySerializer === 'function'\r\n        ? options.querySerializer\r\n        : createQuerySerializer(options.querySerializer),\r\n    url: options.url,\r\n  });\r\n\r\nexport const mergeConfigs = (a: Config, b: Config): Config => {\r\n  const config = { ...a, ...b };\r\n  if (config.baseUrl?.endsWith('/')) {\r\n    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);\r\n  }\r\n  config.headers = mergeHeaders(a.headers, b.headers);\r\n  return config;\r\n};\r\n\r\nconst headersEntries = (headers: Headers): Array<[string, string]> => {\r\n  const entries: Array<[string, string]> = [];\r\n  headers.forEach((value, key) => {\r\n    entries.push([key, value]);\r\n  });\r\n  return entries;\r\n};\r\n\r\nexport const mergeHeaders = (\r\n  ...headers: Array<Required<Config>['headers'] | undefined>\r\n): Headers => {\r\n  const mergedHeaders = new Headers();\r\n  for (const header of headers) {\r\n    if (!header) {\r\n      continue;\r\n    }\r\n\r\n    const iterator =\r\n      header instanceof Headers\r\n        ? headersEntries(header)\r\n        : Object.entries(header);\r\n\r\n    for (const [key, value] of iterator) {\r\n      if (value === null) {\r\n        mergedHeaders.delete(key);\r\n      } else if (Array.isArray(value)) {\r\n        for (const v of value) {\r\n          mergedHeaders.append(key, v as string);\r\n        }\r\n      } else if (value !== undefined) {\r\n        // assume object headers are meant to be JSON stringified, i.e. their\r\n        // content value in OpenAPI specification is 'application/json'\r\n        mergedHeaders.set(\r\n          key,\r\n          typeof value === 'object' ? JSON.stringify(value) : (value as string),\r\n        );\r\n      }\r\n    }\r\n  }\r\n  return mergedHeaders;\r\n};\r\n\r\ntype ErrInterceptor<Err, Res, Req, Options> = (\r\n  error: Err,\r\n  response: Res,\r\n  request: Req,\r\n  options: Options,\r\n) => Err | Promise<Err>;\r\n\r\ntype ReqInterceptor<Req, Options> = (\r\n  request: Req,\r\n  options: Options,\r\n) => Req | Promise<Req>;\r\n\r\ntype ResInterceptor<Res, Req, Options> = (\r\n  response: Res,\r\n  request: Req,\r\n  options: Options,\r\n) => Res | Promise<Res>;\r\n\r\nclass Interceptors<Interceptor> {\r\n  fns: Array<Interceptor | null> = [];\r\n\r\n  clear(): void {\r\n    this.fns = [];\r\n  }\r\n\r\n  eject(id: number | Interceptor): void {\r\n    const index = this.getInterceptorIndex(id);\r\n    if (this.fns[index]) {\r\n      this.fns[index] = null;\r\n    }\r\n  }\r\n\r\n  exists(id: number | Interceptor): boolean {\r\n    const index = this.getInterceptorIndex(id);\r\n    return Boolean(this.fns[index]);\r\n  }\r\n\r\n  getInterceptorIndex(id: number | Interceptor): number {\r\n    if (typeof id === 'number') {\r\n      return this.fns[id] ? id : -1;\r\n    }\r\n    return this.fns.indexOf(id);\r\n  }\r\n\r\n  update(\r\n    id: number | Interceptor,\r\n    fn: Interceptor,\r\n  ): number | Interceptor | false {\r\n    const index = this.getInterceptorIndex(id);\r\n    if (this.fns[index]) {\r\n      this.fns[index] = fn;\r\n      return id;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  use(fn: Interceptor): number {\r\n    this.fns.push(fn);\r\n    return this.fns.length - 1;\r\n  }\r\n}\r\n\r\nexport interface Middleware<Req, Res, Err, Options> {\r\n  error: Interceptors<ErrInterceptor<Err, Res, Req, Options>>;\r\n  request: Interceptors<ReqInterceptor<Req, Options>>;\r\n  response: Interceptors<ResInterceptor<Res, Req, Options>>;\r\n}\r\n\r\nexport const createInterceptors = <Req, Res, Err, Options>(): Middleware<\r\n  Req,\r\n  Res,\r\n  Err,\r\n  Options\r\n> => ({\r\n  error: new Interceptors<ErrInterceptor<Err, Res, Req, Options>>(),\r\n  request: new Interceptors<ReqInterceptor<Req, Options>>(),\r\n  response: new Interceptors<ResInterceptor<Res, Req, Options>>(),\r\n});\r\n\r\nconst defaultQuerySerializer = createQuerySerializer({\r\n  allowReserved: false,\r\n  array: {\r\n    explode: true,\r\n    style: 'form',\r\n  },\r\n  object: {\r\n    explode: true,\r\n    style: 'deepObject',\r\n  },\r\n});\r\n\r\nconst defaultHeaders = {\r\n  'Content-Type': 'application/json',\r\n};\r\n\r\nexport const createConfig = <T extends ClientOptions = ClientOptions>(\r\n  override: Config<Omit<ClientOptions, keyof T> & T> = {},\r\n): Config<Omit<ClientOptions, keyof T> & T> => ({\r\n  ...jsonBodySerializer,\r\n  headers: defaultHeaders,\r\n  parseAs: 'auto',\r\n  querySerializer: defaultQuerySerializer,\r\n  ...override,\r\n});\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport { createSseClient } from '../core/serverSentEvents.gen';\r\nimport type { HttpMethod } from '../core/types.gen';\r\nimport { getValidRequestBody } from '../core/utils.gen';\r\nimport type {\r\n  Client,\r\n  Config,\r\n  RequestOptions,\r\n  ResolvedRequestOptions,\r\n} from './types.gen';\r\nimport {\r\n  buildUrl,\r\n  createConfig,\r\n  createInterceptors,\r\n  getParseAs,\r\n  mergeConfigs,\r\n  mergeHeaders,\r\n  setAuthParams,\r\n} from './utils.gen';\r\n\r\ntype ReqInit = Omit<RequestInit, 'body' | 'headers'> & {\r\n  body?: any;\r\n  headers: ReturnType<typeof mergeHeaders>;\r\n};\r\n\r\nexport const createClient = (config: Config = {}): Client => {\r\n  let _config = mergeConfigs(createConfig(), config);\r\n\r\n  const getConfig = (): Config => ({ ..._config });\r\n\r\n  const setConfig = (config: Config): Config => {\r\n    _config = mergeConfigs(_config, config);\r\n    return getConfig();\r\n  };\r\n\r\n  const interceptors = createInterceptors<\r\n    Request,\r\n    Response,\r\n    unknown,\r\n    ResolvedRequestOptions\r\n  >();\r\n\r\n  const beforeRequest = async (options: RequestOptions) => {\r\n    const opts = {\r\n      ..._config,\r\n      ...options,\r\n      fetch: options.fetch ?? _config.fetch ?? globalThis.fetch,\r\n      headers: mergeHeaders(_config.headers, options.headers),\r\n      serializedBody: undefined,\r\n    };\r\n\r\n    if (opts.security) {\r\n      await setAuthParams({\r\n        ...opts,\r\n        security: opts.security,\r\n      });\r\n    }\r\n\r\n    if (opts.requestValidator) {\r\n      await opts.requestValidator(opts);\r\n    }\r\n\r\n    if (opts.body !== undefined && opts.bodySerializer) {\r\n      opts.serializedBody = opts.bodySerializer(opts.body);\r\n    }\r\n\r\n    // remove Content-Type header if body is empty to avoid sending invalid requests\r\n    if (opts.body === undefined || opts.serializedBody === '') {\r\n      opts.headers.delete('Content-Type');\r\n    }\r\n\r\n    const url = buildUrl(opts);\r\n\r\n    return { opts, url };\r\n  };\r\n\r\n  const request: Client['request'] = async (options) => {\r\n    // @ts-expect-error\r\n    const { opts, url } = await beforeRequest(options);\r\n    const requestInit: ReqInit = {\r\n      redirect: 'follow',\r\n      ...opts,\r\n      body: getValidRequestBody(opts),\r\n    };\r\n\r\n    let request = new Request(url, requestInit);\r\n\r\n    for (const fn of interceptors.request.fns) {\r\n      if (fn) {\r\n        request = await fn(request, opts);\r\n      }\r\n    }\r\n\r\n    // fetch must be assigned here, otherwise it would throw the error:\r\n    // TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation\r\n    const _fetch = opts.fetch!;\r\n    let response = await _fetch(request);\r\n\r\n    for (const fn of interceptors.response.fns) {\r\n      if (fn) {\r\n        response = await fn(response, request, opts);\r\n      }\r\n    }\r\n\r\n    const result = {\r\n      request,\r\n      response,\r\n    };\r\n\r\n    if (response.ok) {\r\n      const parseAs =\r\n        (opts.parseAs === 'auto'\r\n          ? getParseAs(response.headers.get('Content-Type'))\r\n          : opts.parseAs) ?? 'json';\r\n\r\n      if (\r\n        response.status === 204 ||\r\n        response.headers.get('Content-Length') === '0'\r\n      ) {\r\n        let emptyData: any;\r\n        switch (parseAs) {\r\n          case 'arrayBuffer':\r\n          case 'blob':\r\n          case 'text':\r\n            emptyData = await response[parseAs]();\r\n            break;\r\n          case 'formData':\r\n            emptyData = new FormData();\r\n            break;\r\n          case 'stream':\r\n            emptyData = response.body;\r\n            break;\r\n          case 'json':\r\n          default:\r\n            emptyData = {};\r\n            break;\r\n        }\r\n        return opts.responseStyle === 'data'\r\n          ? emptyData\r\n          : {\r\n              data: emptyData,\r\n              ...result,\r\n            };\r\n      }\r\n\r\n      let data: any;\r\n      switch (parseAs) {\r\n        case 'arrayBuffer':\r\n        case 'blob':\r\n        case 'formData':\r\n        case 'json':\r\n        case 'text':\r\n          data = await response[parseAs]();\r\n          break;\r\n        case 'stream':\r\n          return opts.responseStyle === 'data'\r\n            ? response.body\r\n            : {\r\n                data: response.body,\r\n                ...result,\r\n              };\r\n      }\r\n\r\n      if (parseAs === 'json') {\r\n        if (opts.responseValidator) {\r\n          await opts.responseValidator(data);\r\n        }\r\n\r\n        if (opts.responseTransformer) {\r\n          data = await opts.responseTransformer(data);\r\n        }\r\n      }\r\n\r\n      return opts.responseStyle === 'data'\r\n        ? data\r\n        : {\r\n            data,\r\n            ...result,\r\n          };\r\n    }\r\n\r\n    const textError = await response.text();\r\n    let jsonError: unknown;\r\n\r\n    try {\r\n      jsonError = JSON.parse(textError);\r\n    } catch {\r\n      // noop\r\n    }\r\n\r\n    const error = jsonError ?? textError;\r\n    let finalError = error;\r\n\r\n    for (const fn of interceptors.error.fns) {\r\n      if (fn) {\r\n        finalError = (await fn(error, response, request, opts)) as string;\r\n      }\r\n    }\r\n\r\n    finalError = finalError || ({} as string);\r\n\r\n    if (opts.throwOnError) {\r\n      throw finalError;\r\n    }\r\n\r\n    // TODO: we probably want to return error and improve types\r\n    return opts.responseStyle === 'data'\r\n      ? undefined\r\n      : {\r\n          error: finalError,\r\n          ...result,\r\n        };\r\n  };\r\n\r\n  const makeMethodFn =\r\n    (method: Uppercase<HttpMethod>) => (options: RequestOptions) =>\r\n      request({ ...options, method });\r\n\r\n  const makeSseFn =\r\n    (method: Uppercase<HttpMethod>) => async (options: RequestOptions) => {\r\n      const { opts, url } = await beforeRequest(options);\r\n      return createSseClient({\r\n        ...opts,\r\n        body: opts.body as BodyInit | null | undefined,\r\n        headers: opts.headers as unknown as Record<string, string>,\r\n        method,\r\n        onRequest: async (url, init) => {\r\n          let request = new Request(url, init);\r\n          for (const fn of interceptors.request.fns) {\r\n            if (fn) {\r\n              request = await fn(request, opts);\r\n            }\r\n          }\r\n          return request;\r\n        },\r\n        url,\r\n      });\r\n    };\r\n\r\n  return {\r\n    buildUrl,\r\n    connect: makeMethodFn('CONNECT'),\r\n    delete: makeMethodFn('DELETE'),\r\n    get: makeMethodFn('GET'),\r\n    getConfig,\r\n    head: makeMethodFn('HEAD'),\r\n    interceptors,\r\n    options: makeMethodFn('OPTIONS'),\r\n    patch: makeMethodFn('PATCH'),\r\n    post: makeMethodFn('POST'),\r\n    put: makeMethodFn('PUT'),\r\n    request,\r\n    setConfig,\r\n    sse: {\r\n      connect: makeSseFn('CONNECT'),\r\n      delete: makeSseFn('DELETE'),\r\n      get: makeSseFn('GET'),\r\n      head: makeSseFn('HEAD'),\r\n      options: makeSseFn('OPTIONS'),\r\n      patch: makeSseFn('PATCH'),\r\n      post: makeSseFn('POST'),\r\n      put: makeSseFn('PUT'),\r\n      trace: makeSseFn('TRACE'),\r\n    },\r\n    trace: makeMethodFn('TRACE'),\r\n  } as Client;\r\n};\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport { type ClientOptions, type Config, createClient, createConfig } from './client';\r\nimport type { ClientOptions as ClientOptions2 } from './types.gen';\r\n\r\n/**\r\n * The `createClientConfig()` function will be called on client initialization\r\n * and the returned object will become the client's initial configuration.\r\n *\r\n * You may want to initialize your client this way instead of calling\r\n * `setConfig()`. This is useful for example if you're using Next.js\r\n * to ensure your client always has the correct values.\r\n */\r\nexport type CreateClientConfig<T extends ClientOptions = ClientOptions2> = (override?: Config<ClientOptions & T>) => Config<Required<ClientOptions> & T>;\r\n\r\nexport const client = createClient(createConfig<ClientOptions2>({\r\n    baseUrl: 'https://localhost:5000'\r\n}));\r\n","import type {\r\n  UmbEntryPointOnInit,\r\n  UmbEntryPointOnUnload,\r\n} from \"@umbraco-cms/backoffice/extension-api\";\r\nimport { UMB_AUTH_CONTEXT } from \"@umbraco-cms/backoffice/auth\";\r\nimport { client } from \"../api/client.gen.js\";\r\n\r\n// load up the manifests here\r\nexport const onInit: UmbEntryPointOnInit = (_host, _extensionRegistry) => {\r\n  console.log(\"Hello from my extension ðŸŽ‰\");\r\n  // Will use only to add in Open API config with generated TS OpenAPI HTTPS Client\r\n  // Do the OAuth token handshake stuff\r\n  _host.consumeContext(UMB_AUTH_CONTEXT, async (authContext) => {\r\n    // Get the token info from Umbraco\r\n    const config = authContext?.getOpenApiConfiguration();\r\n\r\n    client.setConfig({\r\n      auth: config?.token ?? undefined,\r\n      baseUrl: config?.base ?? \"\",\r\n      credentials: config?.credentials ?? \"same-origin\",\r\n    });\r\n  });\r\n};\r\n\r\nexport const onUnload: UmbEntryPointOnUnload = (_host, _extensionRegistry) => {\r\n  console.log(\"Goodbye from my extension ðŸ‘‹\");\r\n};\r\n"],"names":["joinedValues","config","request","url"],"mappings":"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"}